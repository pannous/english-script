
# ruby +++ better blocks + lambdas !!!
# ruby ++ much more forgiving and convenient, i.e. z=map[x] vs if x in map: map[x]
# ruby ++ nicer string templates "Variable #{type} #{name}=#{value}"
# ruby + jruby better, class extensions
# ruby + mirah: native 'ruby' on jvm
# ruby + def 'properties'   def y; @y; end    def y=(z); @y=z; end , see (ugly) attr_reader ...
# ruby + clean function approach, e.g. def []=(index,values) ...
# ruby + nicer 'and'+'or' concatenations  a?b:c or d and raise Ex
# ruby - less modules, more beautiful language => less need for angle!
# ruby - methods less 1st class than in python! ('ok' via method(:symbol), send)
# ruby -: can't access variables in methods without '@' !!
# ruby -- NO types/type hints!! (vs py3)
# ruby -- no annotations!
# ruby --- no nice dynamic programmatic properties:
            a.x=8  NoMethodError: undefined method `x='
            workaround: def a.x; 8;end
            OR a.methods << def x; 8;end  (WOW)
            OR class << a; attr_accessor :x; end and a.x=8
            OR A.send(:attr_accessor, :x) and a.x=8 #CLASS!
            OR A.class.send(:define_method, :x, lambda{8}) #CLASS!
            OR sometimes method_missing
            OR lol: http://www.infoq.com/articles/properties-metaprogramming
            # http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime#C.23
            # dynamic a = new System.Dynamic.ExpandoObject();
            # a.x = 1; // Adding a new property

# java: https://stackoverflow.com/questions/6680674/can-a-java-class-add-a-method-to-itself-at-runtime =>
# http://www.jboss.org/javassist https://github.com/jboss-javassist/javassist
# python ++: more modules
# python ++: dynamic properties
# python ++: ironpython ok!
# python ++: type hints (py3)
# python ++: annotations
# python ++: TO/FRO bytecode, NATIVE (sometimes)
# python ++: Ast better integrated(!!) + cleaner!! + compile,exec,pyc emitter!!
# python ++: Constructors() interchangeable with methods, can be very handy someday, and nice
# python ++: can access variables in methods without '@' !!
# python +: list concatenation
# python +: named parameters
# python +: better reflection + docs (dir, help)
# python +-: functions proper(!) 1st class citizens [problem: () not default!]
# python +-: properties ok'ish:  p=property(getter,setter)
# python +: 'in; operator
# python +: stricter: i.e. ruby z=map[x] (NIL) vs if x in map: map[x]
# python -- LESS FORGIVING! ValueError: list.remove(x): x not in list , if string.index(x): ValueError: substring not found ETC ETC
# python -- missing SO MANY FUNCTIONS! :
# python - unsupported operand type(s) for -: 'list' and 'list', AttributeError: 'list' object has no attribute 'each' ETC **
# python (-) backtrace
# python - annoying (self), : , () -> DANGEROUS!! (ok if generated?)
# python - NO class extensions for builtins! (ok with 'macros' / subclass construction (?))
# python -- running angle ok, debugging SLOOOOOW! (same algorithm as ruby, maybe caller() is expensive?)
# python ---- variable scope nightmare!! lambdas + block variable scope !!!!! 'nonlocal' keyword :(
# python ---- explicit global/class(self) self.EVERYTHING!!!

# both ++ mixins  python:class Request(BaseRequest, AcceptMixin), ruby: include AcceptMixin
# both ++ alias neu alt  python: neu=alt def neu(): alt()

# What separates a mixin from multiple inheritance? Is it just a matter of semantics?
Yes.





** ValueError: list.remove(x): x not in list
** RUBY: # (the.nodes - old_nodes).each{|n| n.invalidate}
** PYTHON: -- for fuck in old_nodes:
                if fuck in nodes:
                    nodes.remove(fuck)
            the.nodes.each(lambda n: n.invalidate())
            AttributeError: 'list' object has no attribute 'each' WTF -=->
for n in the.nodes: n.invalid()

def dispatch printType(Void x) {
  "it's null"
}

to print an empty car:
  "it's null"